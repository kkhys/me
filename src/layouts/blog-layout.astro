---
import type { InferEntrySchema } from "astro:content";
import ArrowLeftIcon from "@lucide/astro/icons/arrow-left";
import type { MarkdownHeading } from "astro";
import { emojiSvg } from "#/components/emoji-svg";
import SEO from "#/components/seo.astro";
import EmojiEyeCatch from "#/components/ui/emoji-eye-catch.astro";
import Separator from "#/components/ui/separator.astro";
import EntryList from "#/features/blog/components/ui/entry-list.astro";
import TableOfContent from "#/features/blog/components/ui/table-of-content.astro";
import TagCloud from "#/features/blog/components/ui/tag-cloud.astro";
import { getCategoryBySlug } from "#/features/blog/config/category";
import { tags as allTags } from "#/features/blog/config/tag";
import { getRelatedPosts } from "#/features/blog/utils/entry";
import BaseLayout from "#/layouts/base-layout.astro";
import { BASE_URL } from "#/lib/base-url";
import { cn } from "#/lib/ui";

interface Props extends InferEntrySchema<"blog"> {
  id: string;
  headings: MarkdownHeading[];
}

const {
  id,
  title,
  emoji,
  category,
  tags,
  publishedAt,
  publishedAtString,
  updatedAt,
  description,
  status,
  headings,
} = Astro.props;

const categorySlug = category.toLowerCase();
const categoryObject = getCategoryBySlug(categorySlug);

if (!categoryObject) {
  throw new Error(`Category "${categorySlug}" not found`);
}

const allTagCloudItems = await Promise.all(
  allTags?.map(async (tag) => ({
    ...tag,
    emojiSvg: await emojiSvg({ emoji: tag.emoji, isColored: true }),
  })) || [],
);

const tagCloudItems = allTagCloudItems.filter(({ title }) =>
  tags?.includes(title as (typeof tags)[number]),
);

const relatedPosts = await getRelatedPosts({ id, category });
---

<BaseLayout>
  <SEO
      title={title}
      description={description}
      imageUrl={`${BASE_URL}/api/og/${id}.png`}
      type='article'
      publishedTime={publishedAt}
      modifiedTime={updatedAt ?? publishedAt}
      category={categoryObject.label}
      tags={tagCloudItems.map((tag) => tag.label)}
      slot='seo'
  />
  <slot name='head' slot='head' />
  <section>
    <div class="mb-4 xl:fixed xl:top-0 xl:translate-y-[138px] xl:-translate-x-[260px]">
      <span class="inline-flex gap-1.5 items-center text-xs">
        <a href="/blog" class="inline-flex gap-1 items-center text-muted-foreground hover:underline">
          <ArrowLeftIcon class="size-3.5" />
          ブログ
        </a>
        <span class="text-muted-foreground">/</span>
        <b class="font-semibold">
          <a href={`/blog/categories/${categorySlug}`} class="hover:underline">
            {categoryObject.label}
          </a>
        </b>
      </span>
    </div>
    <div class={cn(status === 'draft' && 'flex justify-between items-center')}>
      <EmojiEyeCatch emoji={emoji} />
      {status === "draft" && (
          <span class="text-xs text-red-400">Draft</span>
      )}
    </div>
    <h1 class="mt-4 font-semibold">{title}</h1>
    <div class="mt-2 flex items-center justify-between">
      <time datetime={publishedAt.toISOString()} class="text-sm text-muted-foreground palt">
        {publishedAtString}
      </time>
    </div>
  </section>
  <section class="mt-16">
    {headings.length > 1 && (
        <TableOfContent headings={headings} />
    )}
    <article class="prose">
      <slot />
    </article>
    {tagCloudItems && (
        <TagCloud tags={tagCloudItems} class="mt-12" />
    )}
    <Separator class="mt-12" />
    {relatedPosts?.length > 0 && (
      <div class="mt-12 space-y-6">
        <div class="font-medium leading-7">こちらもおすすめ</div>
        <EntryList blogEntries={relatedPosts} />
      </div>
    )}
  </section>
</BaseLayout>

<script>
  const handleHeadingIntersection = () => {
    const observerOptions: IntersectionObserverInit = {
      root: null,
      rootMargin: '0px 0px -85% 0px',
      threshold: 0
    };

    const activeClass = 'active';

    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (!entry.isIntersecting) return;

        const id = entry.target.getAttribute('id');

        document.querySelectorAll(`.${activeClass}`)
          .forEach((item) => item.classList.remove(activeClass));

        const link = document.querySelector(`li > a[href="#${id}"]`);
        const toc = document.querySelector(`div[data-toc="${id}"]`);

        link?.classList.add(activeClass);
        toc?.classList.add(activeClass);
      })
    }, observerOptions);

    const headings = document.querySelectorAll('h2[id], h3[id]');
    headings.forEach((heading) => observer.observe(heading));

    if (headings.length > 1) {
      const firstHeadingId = headings[0]?.getAttribute('id');
      if (firstHeadingId) {
        const firstLink = document.querySelector(`li > a[href="#${firstHeadingId}"]`);
        const firstToc = document.querySelector(`div[data-toc="${firstHeadingId}"]`);

        firstLink?.classList.add(activeClass);
        firstToc?.classList.add(activeClass);
      }
    }

  }

  handleHeadingIntersection()
</script>
